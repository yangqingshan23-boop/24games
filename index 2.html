<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">
    <title>24 Point Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Arial', sans-serif;
        }

        body {
            min-height: 100vh;
            background: #f5f5f5;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            gap: 25px;
            touch-action: manipulation;
        }

        h1 {
            color: #2c3e50;
            font-size: 2.2rem;
            font-weight: 700;
            text-align: center;
        }

        .num-container {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .num-card {
            width: 80px;
            height: 80px;
            background: #3498db;
            color: white;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2.5rem;
            font-weight: 600;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            user-select: none;
        }

        .btn-group {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            justify-content: center;
            width: 100%;
            max-width: 500px;
        }

        button {
            flex: 1;
            min-width: 120px;
            height: 55px;
            border: none;
            border-radius: 8px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            user-select: none;
        }

        .new-game {
            background: #2ecc71;
            color: white;
        }

        .calculate {
            background: #f39c12;
            color: white;
        }

        .hint {
            background: #9b59b6;
            color: white;
        }

        .division-switch {
            background: #e74c3c;
            color: white;
        }

        .division-switch.active {
            background: #27ae60;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }

        button:active {
            transform: translateY(0);
            opacity: 0.9;
        }

        .result-area {
            width: 100%;
            max-width: 500px;
            min-height: 90px;
            background: white;
            border-radius: 12px;
            padding: 18px 15px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            font-size: 1.05rem;
            font-weight: 500;
            color: #2c3e50;
            line-height: 1.8;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            white-space: pre-wrap;
            user-select: text;
        }

        /* 手机端精准适配 */
        @media (max-width: 480px) {
            .num-card {
                width: 65px;
                height: 65px;
                font-size: 2rem;
            }
            h1 {
                font-size: 1.7rem;
            }
            button {
                min-width: 90px;
                height: 50px;
                font-size: 0.95rem;
            }
            .result-area {
                font-size: 0.95rem;
                min-height: 80px;
                padding: 15px 12px;
            }
            .btn-group {
                gap: 10px;
            }
            .num-container {
                gap: 12px;
            }
        }
        @media (max-width: 360px) {
            .num-card {
                width: 60px;
                height: 60px;
                font-size: 1.8rem;
            }
            button {
                min-width: 80px;
                height: 45px;
                font-size: 0.9rem;
            }
        }
    </style>
</head>
<body>
    <h1>24 Point Game</h1>
    <div class="num-container" id="numContainer"></div>
    <div class="btn-group">
        <button class="new-game" id="newGame">New Game</button>
        <button class="calculate" id="calculate">Calculate</button>
        <button class="hint" id="hint">Hint</button>
        <button class="division-switch" id="divisionSwitch">Division: OFF</button>
    </div>
    <div class="result-area" id="resultArea">Click New Game to start!</div>

    <script>
        // 全局变量 - 简化+初始化保障
        let currentNums = [3,4,6,8]; // 初始值避免空数组问题
        let divisionEnabled = false;
        const MAX_LOOP = 30; // 减少循环次数，避免阻塞
        // DOM元素 - 提前获取+兜底
        const numContainer = document.getElementById('numContainer') || {};
        const resultArea = document.getElementById('resultArea') || { textContent: '' };
        const divisionSwitch = document.getElementById('divisionSwitch') || {};
        const newGameBtn = document.getElementById('newGame') || {};
        const calculateBtn = document.getElementById('calculate') || {};
        const hintBtn = document.getElementById('hint') || {};

        // 初始化 - 简化逻辑，避免嵌套阻塞
        initEventListeners();
        renderNums(); // 直接渲染初始值，无需等onload
        resultArea.textContent = 'Click New Game to start!';

        // 事件绑定 - 极简绑定，增加防重复点击兜底
        function initEventListeners() {
            // 除法开关
            divisionSwitch.addEventListener?.('click', () => {
                divisionEnabled = !divisionEnabled;
                divisionSwitch.classList?.toggle('active');
                divisionSwitch.textContent = `Division: ${divisionEnabled ? 'ON' : 'OFF'}`;
                resultArea.textContent = `Division is now ${divisionEnabled ? 'enabled' : 'disabled'}. Click New Game for new valid numbers!`;
            });

            // 新游戏 - 核心：防重复点击+立即执行
            let isGenerating = false;
            newGameBtn.addEventListener?.('click', () => {
                if (isGenerating) return; // 防止重复点击导致卡死
                isGenerating = true;
                generateSolvableNums();
                isGenerating = false;
            });

            // 计算解法
            calculateBtn.addEventListener?.('click', () => {
                if (!currentNums.length) return;
                const solutions = solve24(currentNums, divisionEnabled);
                resultArea.textContent = solutions.length 
                    ? `Solutions:\n${solutions.join('\n')}` 
                    : 'No solution found! Click New Game!';
            });

            // 核心提示：最低优先级二元运算 + 鼓励语
            hintBtn.addEventListener?.('click', showLowestPriorityHint);
        }

        // 生成可解数字 - 【底层优化】简化可解校验，秒生成不阻塞
        function generateSolvableNums() {
            window.speechSynthesis.cancel();
            resultArea.textContent = 'Generating new numbers...';
            let loopCount = 0;
            let found = false;

            // 简化循环，快速找可解数字
            while (loopCount < MAX_LOOP && !found) {
                loopCount++;
                // 生成1-10的4个随机数
                const tempNums = [1,2,3,4].map(() => Math.floor(Math.random() * 10) + 1);
                // 轻量可解校验 - 优化递归，避免阻塞
                if (isSolvableSimple(tempNums, divisionEnabled)) {
                    currentNums = tempNums;
                    found = true;
                }
            }

            // 兜底：没找到就用万能组合
            if (!found) currentNums = [3,4,6,8];
            // 立即渲染，不等待
            renderNums();
            resultArea.textContent = 'New numbers generated! Try to make 24 (follow operator priority)!';
        }

        // 渲染数字卡片 - 极简逻辑，保障执行
        function renderNums() {
            numContainer.innerHTML = '';
            currentNums.forEach(num => {
                const card = document.createElement('div');
                card.className = 'num-card';
                card.textContent = num;
                numContainer.appendChild(card);
            });
        }

        // 核心提示：提取最低优先级二元运算 + 新增鼓励语
        function showLowestPriorityHint() {
            if (!currentNums.length) {
                resultArea.textContent = 'Please start a new game first!';
                return;
            }
            window.speechSynthesis.cancel();
            const solutions = solve24(currentNums, divisionEnabled);
            if (!solutions.length) {
                resultArea.textContent = 'No solution found! Click New Game!';
                return;
            }

            const mainExpr = solutions[0];
            const lowestOp = extractLowestPriorityOp(mainExpr);
            let hintText, encourageText = "I believe you can do it!"; // 新增鼓励语
            // 运算提示+鼓励语组合
            if (lowestOp) {
                const { n1, op, n2, res } = lowestOp;
                const restNums = getRestNumsWithResult(currentNums, n1, n2, res);
                hintText = `Follow priority! First calculate ${n1} ${op} ${n2} = ${res}, then make 24 with (${restNums.join(', ')}). ${encourageText}`;
            } else {
                hintText = `First calculate +/- (low priority), then ×/÷ (high priority) to make 24! ${encourageText}`;
            }

            resultArea.textContent = hintText;
            playHintVoice(hintText); // 语音也会播报鼓励语
        }

        // 提取最低优先级二元运算 - 保留核心逻辑，简化正则
        function extractLowestPriorityOp(expr) {
            // 1. 括号内的加减（最低优先级）
            const bracketReg = /\((\d+)\s*([+-])\s*(\d+)\)/;
            const bMatch = expr.match(bracketReg);
            if (bMatch) {
                const [,n1,op,n2] = bMatch;
                return { n1:+n1, op, n2:+n2, res: calculateOp(+n1, op, +n2) };
            }
            // 2. 顶层加减
            const topAddSubReg = /(\d+)\s*([+-])\s*(\d+)(?![\s\S]*[×÷])/;
            const tMatch = expr.match(topAddSubReg);
            if (tMatch) {
                const [,n1,op,n2] = tMatch;
                return { n1:+n1, op, n2:+n2, res: calculateOp(+n1, op, +n2) };
            }
            // 3. 乘除（无加减时）
            const mulDivReg = /(\d+)\s*([×÷])\s*(\d+)/;
            const mMatch = expr.match(mulDivReg);
            if (mMatch) {
                const [,n1,op,n2] = mMatch;
                return { n1:+n1, op, n2:+n2, res: calculateOp(+n1, op, +n2) };
            }
            return null;
        }

        // 工具函数：计算二元运算
        function calculateOp(n1, op, n2) {
            switch (op) {
                case '+': return n1 + n2;
                case '-': return n1 - n2;
                case '×': return n1 * n2;
                case '÷': return n2 === 0 ? 0 : n1 / n2;
                default: return 0;
            }
        }

        // 工具函数：获取剩余数字（修复重复数字，保障执行）
        function getRestNumsWithResult(original, n1, n2, res) {
            const temp = [...original];
            // 依次移除，适配重复数字
            const i1 = temp.findIndex(x => x === n1);
            if (i1 > -1) temp.splice(i1, 1);
            const i2 = temp.findIndex(x => x === n2);
            if (i2 > -1) temp.splice(i2, 1);
            temp.push(res);
            return temp.sort((a,b)=>a-b);
        }

        // 语音播报 - 包含鼓励语，增加异常捕获
        function playHintVoice(text) {
            try {
                const utterance = new SpeechSynthesisUtterance(text);
                utterance.lang = 'en-US';
                utterance.volume = 1;
                utterance.rate = 0.8;
                window.speechSynthesis.speak(utterance);
            } catch (e) { /* 静默失败，不影响主功能 */ }
        }

        // 【底层优化】轻量可解校验 - 简化递归，避免卡死
        function isSolvableSimple(nums, allowDivision) {
            const ops = allowDivision 
                ? [(a,b)=>a+b, (a,b)=>a-b, (a,b)=>a*b, (a,b)=>b===0?NaN:a/b]
                : [(a,b)=>a+b, (a,b)=>a-b, (a,b)=>a*b];

            // 简化排列：只生成部分排列，快速校验，不做全排列
            const check = (arr) => {
                if (arr.length === 1) return Math.abs(arr[0] -24) < 1e-6;
                for (let i=0; i<arr.length; i++) {
                    for (let j=i+1; j<arr.length; j++) {
                        const rest = arr.filter((_,k) => k!==i && k!==j);
                        for (const op of ops) {
                            const v1 = op(arr[i], arr[j]), v2 = op(arr[j], arr[i]);
                            if (!isNaN(v1) && check([...rest, v1])) return true;
                            if (!isNaN(v2) && check([...rest, v2])) return true;
                        }
                    }
                }
                return false;
            };
            return check(nums);
        }

        // 24点求解 - 简化括号和去重，保障执行速度
        function solve24(nums, allowDivision) {
            const solutions = new Set();
            const ops = allowDivision 
                ? [['+',(a,b)=>a+b],['-',(a,b)=>a-b],['×',(a,b)=>a*b],['÷',(a,b)=>b===0?NaN:a/b]]
                : [['+',(a,b)=>a+b],['-',(a,b)=>a-b],['×',(a,b)=>a*b]];

            // 简化排列组合
            const permute = (arr) => arr.length ===1 ? [arr] : arr.flatMap((v,i) => permute(arr.filter((_,k)=>k!==i)).map(p=>[v,...p]));
            const combine = (arr) => {
                if (arr.length ===1) return [{v:arr[0], s:arr[0].toString()}];
                const res = [];
                for (let i=1; i<arr.length; i++) {
                    const l = combine(arr.slice(0,i)), r = combine(arr.slice(i));
                    for (const L of l) for (const R of r) for (const [op,fn] of ops) {
                        const val = fn(L.v, R.v);
                        if (isNaN(val) || val<0 || (op==='÷' && val%1!==0)) continue;
                        // 简化括号添加
                        let sL = L.s, sR = R.s;
                        if (/[+-]/.test(L.s) && /[×÷]/.test(op)) sL = `(${sL})`;
                        if ((/[+-]/.test(R.s) && /[×÷]/.test(op)) || /[-÷]/.test(op)) sR = `(${sR})`;
                        res.push({v:val, s:`${sL} ${op} ${sR}`});
                    }
                }
                return res;
            };

            // 遍历求解
            permute(nums).forEach(p => {
                combine(p).forEach(item => {
                    if (Math.abs(item.v -24) <1e-6) solutions.add(simplifyBracketSimple(item.s));
                });
            });
            return Array.from(solutions);
        }

        // 简化括号精简 - 保障执行，不做复杂正则
        function simplifyBracketSimple(s) {
            return s.replace(/\((\d+)\)/g, '$1') // 移除单个数字括号
                    .replace(/\s+/g, ' ') // 简化空格
                    .trim();
        }
    </script>
</body>
</html>